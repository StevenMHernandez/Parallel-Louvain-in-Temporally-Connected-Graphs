#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <iostream>
#include <fstream>
#include <float.h>
#include <math.h>
#include <map>
#include <set>
#include <vector>
//#include <mpi.h>
#include "louvain.cpp"

#define DISTANCE_THRESHOLD 10

double distance(double x1, double y1, double x2, double y2) {
    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
}

int main(int argc, char *argv[]) {
    int pointsToCreate = 200;

    int rank = 0, total_tasks;
//    MPI_Init(&argc, &argv);
//    MPI_Comm_size(MPI_COMM_WORLD, &total_tasks);
//    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
//    MPI_Status stat;
    if (rank == 0) { // TODO: remove!

        srandom(rank);

        double *points = (double *) malloc(pointsToCreate * 2 * sizeof(double));

        /// Generate Points in Euclidean Space to use
        if (rank == 0) {
            for (int i = 0; i < pointsToCreate; i++) {
                points[i * 2] = (random() / (double) RAND_MAX) * 100;
                points[(i * 2) + 1] = (random() / (double) RAND_MAX) * 100;

                //* Print the points generated by the current process.
                //* Format: "identifier,i,x,y"
                //printf("generated_points,%i,%lf,%lf\n", i, points[i * 2], points[(i * 2) + 1]);
            }
        }

        struct timespec start, end;
        if (rank == 0) {
            clock_gettime(CLOCK_MONOTONIC_RAW, &start);
        }

        /// Calculate Graph values Gamma (L) and omega (w) all combined into one data structure
        double **L = (double **) malloc(pointsToCreate * sizeof(double *));
        for (int i = 0; i < pointsToCreate; i++) {
            L[i] = (double *) malloc(pointsToCreate * sizeof(double));

            for (int j = 0; j < pointsToCreate; j++) {
                double d = distance(points[i * 2], points[(i * 2) + 1], points[j * 2], points[(j * 2) + 1]);
                L[i][j] = d < DISTANCE_THRESHOLD ? d : -1;
//                L[i][j] = d < DISTANCE_THRESHOLD ? 1 : -1;


                if (L[i][j] != -1) {
                    //* Print the adjacency matrix values (and the associated weights)
                    //* Format: "identifier,i,j,w(i,j)"
                    //printf("adjacency_matrix,%i,%i,%lf\n", i, j, L[i][j]);
                }
            }
        }
        /// Create Communities data structure
        std::vector<std::set<int> > C;
        C.resize(static_cast<unsigned long>(pointsToCreate), std::set<int>());

        /// Run Parallel Louvain here.
        louvain(pointsToCreate, L, C);

        if (rank == 0) {
            clock_gettime(CLOCK_MONOTONIC_RAW, &end);
            //* Print the time take for the given number of processors used and number of cities total
            //* Format: "identifier,num processors,num cities,time(ms)"
            printf("time_taken_ms,%i,%lf\n", total_tasks,
                   (1000000000L * (end.tv_sec - start.tv_sec) + end.tv_nsec - start.tv_nsec) / 1e6);
        }
    } // TODO: remove

//    MPI_Finalize();
    return 0;
}
